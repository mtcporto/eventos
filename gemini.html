<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini Agente - Eventos (Gemini)</title>
  <style>
    :root {
      --primary: #3498db;
      --secondary: #2ecc71;
      --dark: #34495e;
      --light: #f5f5f5;
      --danger: #e74c3c;
      --success: #27ae60;
      --purple: #9b59b6;
      --yellow: #f1c40f;
    }
    
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      padding: 20px; 
      max-width: 800px; 
      margin: auto;
      background-color: #f9f9f9;
      color: #333;
    }
    
    .container {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    
    h2 {
      color: var(--primary);
      border-bottom: 2px solid var(--light);
      padding-bottom: 10px;
      margin-top: 0;
    }
    
    h4 {
      color: var(--dark);
      margin-top: 20px;
      margin-bottom: 10px;
    }
    
    .input-area {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .file-input-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
      width: 100%;
    }
    
    .file-input-label {
      background-color: var(--primary);
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      cursor: pointer;
      display: inline-block;
      text-align: center;
      transition: background-color 0.3s;
    }
    
    .file-input-label:hover {
      background-color: #2980b9;
    }
    
    .file-input {
      position: absolute;
      font-size: 100px;
      opacity: 0;
      right: 0;
      top: 0;
      cursor: pointer;
    }
    
    button {
      background-color: var(--secondary);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
      width: 100%;
      margin: 10px 0;
    }
    
    button:hover {
      background-color: #27ae60;
    }
    
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .preview-container {
      margin: 20px 0;
      text-align: center;
      border: 2px dashed var(--light);
      border-radius: 8px;
      padding: 10px;
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #preview {
      max-width: 100%;
      max-height: 400px;
      border-radius: 4px;
      display: none;
    }
    
    pre {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      border-left: 4px solid var(--primary);
    }
    
    .json-key {
      color: #e74c3c;
    }
    
    .json-value {
      color: #3498db;
    }
    
    .loading {
      display: none;
      text-align: center;
      padding: 20px;
    }
    
    .loading-spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 4px solid var(--primary);
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .result-container {
      background-color: var(--light);
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
    }
    
    .status-message {
      margin: 10px 0;
      font-size: 14px;
      color: #777;
    }
    
    .simple-option {
      margin: 10px 0;
      display: flex;
      align-items: center;
    }
    
    .simple-option input[type="checkbox"] {
      margin-right: 8px;
    }
    
    .mode-toggle {
      display: flex;
      justify-content: center;
      margin-bottom: 15px;
      gap: 10px;
    }
    
    .mode-button {
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s;
      width: auto;
    }
    
    .mode-button.active {
      box-shadow: 0 0 0 2px white, 0 0 0 4px var(--primary);
    }
    
    .ocr-mode {
      background-color: var(--yellow);
      color: #333;
    }
    
    .gemini-mode {
      background-color: var(--purple);
      color: white;
    }
    
    /* Estilos para cartões de eventos */
    .event-card {
      background-color: white;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .event-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--light);
      padding-bottom: 10px;
    }
    
    .event-card-title {
      font-size: 18px;
      font-weight: bold;
      color: var(--dark);
      margin: 0;
    }
    
    .event-card-date {
      font-size: 14px;
      color: var(--primary);
      font-weight: bold;
    }
    
    .event-card-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .event-card-item {
      margin-bottom: 10px;
    }
    
    .event-card-item-label {
      font-size: 12px;
      color: #777;
      margin-bottom: 3px;
    }
    
    .event-card-item-value {
      font-weight: 500;
    }
    
    .event-card-actions {
      margin-top: 15px;
      display: flex;
      justify-content: flex-end;
    }
    
    .event-select {
      margin-right: 10px;
    }
    
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      
      .event-card-content {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Mini Agente de Eventos (Modo Gemini)</h2>
    
    <div style="text-align: center; margin-bottom: 15px;">
      <a href="index.html" style="color: var(--primary); font-size: 0.9em; text-decoration: none;">← Voltar para escolha</a>
      <span style="margin: 0 10px;">|</span>
      <a href="ocr.html" style="color: var(--primary); font-size: 0.9em; text-decoration: none;">Alternar para modo OCR →</a>
      <span style="margin: 0 10px;">|</span>
      <a href="eventos.html" style="color: var(--primary); font-size: 0.9em; text-decoration: none;">Ver todos os eventos →</a>
    </div>
    
    <div class="input-area">
      <div class="file-input-wrapper">
        <label class="file-input-label" for="imageInput">Escolher imagem de evento</label>
        <input class="file-input" type="file" accept="image/*" id="imageInput" />
      </div>
      
      <p style="text-align: center; margin: 10px 0; color: #666;">
        <i>Você também pode colar uma imagem diretamente da área de transferência (Ctrl+V)</i>
      </p>
    </div>
    
    <div class="preview-container">
      <img id="preview" alt="Preview da imagem" />
    </div>
    
    <button id="processButton" onclick="processImage()">Extrair Evento</button>
    
    <div id="loading" class="loading">
      <div class="loading-spinner"></div>
      <p>Processando imagem, por favor aguarde...</p>
      <div class="status-message" id="statusMessage"></div>
    </div>
  </div>
  
  <div class="container result-container" id="resultContainer" style="display: none;">
    <h4>Interpretação do Gemini:</h4>
    <pre id="rawText">---</pre>

    <h4>Eventos detectados:</h4>
    <div id="eventosContainer">
      <!-- Eventos serão adicionados aqui dinamicamente -->
    </div>
    
    <button id="sendButton" onclick="enviarEventos()">Enviar para API</button>
  </div>

  <script>    // --- Configuração ---
    const GEMINI_API_KEY = "AIzaSyAQR7qRaUJ6wpEq_RrGSUzodbkmVbz7Gdk"; // <= SUBSTITUA PELA SUA CHAVE
    const GEMINI_MODEL_ID = "gemini-1.5-flash-latest"; // Modelo a ser usado
    const GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models/";
    
    // Endpoint da API Web2py real
    const API_ENDPOINT = "https://mtcporto2.pythonanywhere.com/eventos/default/eventos";

    // --- Variáveis globais ---
    let rawText = "";
    let eventos = [];  // Array para armazenar múltiplos eventos
    let lastImageData = null;
    
    // --- Inicialização da página ---
    document.addEventListener('DOMContentLoaded', function() {
      const preview = document.getElementById('preview');
      // Garantir que o preview comece oculto
      preview.style.display = 'none';
    });
    
    // Mostrar preview quando uma imagem for selecionada
    document.getElementById("imageInput").addEventListener("change", function() {
      const file = this.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        const preview = document.getElementById("preview");
        preview.src = e.target.result;
        preview.style.display = 'block';  // Mostrar imagem apenas quando carregada
        lastImageData = e.target.result;
      };
      reader.readAsDataURL(file);
      
      // Ocultar resultados quando uma nova imagem for carregada
      document.getElementById("resultContainer").style.display = "none";
    });
    
    // Adicionar suporte para colar imagem da área de transferência
    document.addEventListener('paste', function(event) {
      const items = (event.clipboardData || event.originalEvent.clipboardData).items;
      
      for (const item of items) {
        if (item.type.indexOf('image') === 0) {
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = function(e) {
            const preview = document.getElementById("preview");
            preview.src = e.target.result;
            preview.style.display = "block"; // Mostrar imagem quando colada
            lastImageData = e.target.result;
            
            // Esconder resultados anteriores
            document.getElementById("resultContainer").style.display = "none";
            
            // Opcional: Informar ao usuário que a imagem foi colada
            alert("Imagem colada com sucesso! Clique em 'Extrair Evento' para processar.");
          };
          reader.readAsDataURL(blob);
          break;
        }
      }
    });
    
    // Converter arquivo para base64
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
      });
    }
    
    // Processar imagem com Gemini
    async function processImage() {
      // Mostrar estado de carregamento
      document.getElementById("loading").style.display = "block";
      document.getElementById("processButton").disabled = true;
      
      try {
        // Obter dados da imagem
        const input = document.getElementById("imageInput");
        const file = input.files[0];
        if (!file && !lastImageData) {
          alert("Selecione uma imagem ou cole uma imagem da área de transferência.");
          document.getElementById("loading").style.display = "none";
          document.getElementById("processButton").disabled = false;
          return;
        }
        
        let imageData;
        if (file) {
          imageData = await fileToBase64(file);
        } else if (lastImageData) {
          imageData = lastImageData;
        }
        
        document.getElementById("statusMessage").textContent = "Enviando para Gemini...";
        
        // Construir prompt para o Gemini com análise detalhada sempre ativada
        const promptParaGemini = `
          Analise esta imagem de um cartaz/flyer de evento(s) e extraia todos os eventos mencionados.
          
          Preste atenção aos seguintes detalhes:
          - A imagem pode conter um ou vários eventos diferentes
          - Cada evento deve ter: atração principal, data, hora e local
          - Alguns eventos podem ter informações adicionais como preço, tipo de evento, etc.
          - Se houver apenas um evento, identifique-o normalmente
          - Se houver múltiplos eventos, liste cada um separadamente
          - IMPORTANTE: Estamos no ano de 2025. Todos os eventos devem ocorrer em 2025 ou anos futuros, nunca no passado.
          - Se a data estiver no formato DD/MM sem ano, considere que é 2025.
          
          Para cada evento identificado, extraia:
          - atracao: nome da atração musical, artista ou título do evento
          - data: data do evento no formato DD/MM/2025
          - hora: horário de início no formato HH:MM
          - local: nome do local/estabelecimento onde ocorrerá
          - cidade: cidade onde ocorrerá (se não for especificado, use "João Pessoa")
          - fonte: nome do estabelecimento que está promovendo o evento
          
          Se disponível, também extraia:
          - endereco: endereço completo do local
          - preco: valor da entrada (se aplicável)
          - tipo: tipo do evento (show, festa, lançamento, etc.)
          - descricao: breve descrição ou informações adicionais
          
          Retorne um JSON no seguinte formato:
          {
            "eventos": [
              {
                "atracao": "Nome da Atração 1",
                "data": "DD/MM/2025",
                "hora": "HH:MM",
                "local": "Nome do Local",
                "cidade": "Nome da Cidade",
                "fonte": "Nome do Estabelecimento"
              },
              {
                "atracao": "Nome da Atração 2",
                ...
              }
            ]
          }
          
          Se houver apenas um evento, ainda retorne-o dentro do array "eventos".
          Não inclua eventos duplicados, se parecer o mesmo evento, mantenha apenas uma entrada.
          NUNCA use o ano 2024 em nenhuma data, todos os eventos devem ser de 2025 ou mais recentes.
        `;
        
        // Chamar a API Gemini
        const geminiUrl = `${GEMINI_API_BASE_URL}${GEMINI_MODEL_ID}:generateContent?key=${GEMINI_API_KEY}`;
        const requestBody = {
          contents: [{
            role: 'user',
            parts: [
              { text: promptParaGemini },
              { inline_data: {
                  mime_type: file ? file.type : "image/jpeg",
                  data: imageData.split(',')[1]
                }
              }
            ]
          }],
          generationConfig: { 
            temperature: 0.2,  // Valor baixo para resposta mais consistente
            maxOutputTokens: 1500
          }
        };

        const responseGemini = await fetch(geminiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        if (!responseGemini.ok) {
          throw new Error(`Erro na API do Gemini: ${responseGemini.status}`);
        }
        
        const dadosGemini = await responseGemini.json();
        const textoGerado = dadosGemini?.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!textoGerado) {
          throw new Error("Resposta vazia do Gemini");
        }
        
        // Mostrar a resposta bruta
        document.getElementById("rawText").innerText = textoGerado;
        rawText = textoGerado;
        
        // Extrair os eventos do JSON
        const eventosExtraidos = extrairEventosDeJson(textoGerado);
        
        if (eventosExtraidos && eventosExtraidos.length > 0) {
          eventos = eventosExtraidos;
          
          // Completar informações faltantes com padrões e corrigir datas para 2025
          eventos = eventos.map(evento => {
            // Adicionar cidade padrão se não especificada
            if (!evento.cidade) evento.cidade = "João Pessoa";
            
            // Tratar o formato da data
            if (evento.data) {
              // Se contiver AAAA, substitua pelo ano 2025
              if (evento.data.includes('AAAA')) {
                evento.data = evento.data.replace('AAAA', '2025');
              }
              // Se não tiver ano (formato DD/MM), adicione 2025
              else if (!evento.data.match(/\/\d{4}$/) && !evento.data.match(/\d{4}$/)) {
                evento.data = `${evento.data}/2025`;
              } 
              // Se tiver 2024 como ano, substitua por 2025
              else if (evento.data.includes('2024')) {
                evento.data = evento.data.replace('2024', '2025');
              }
              // Garante que a data está no formato correto
              const partes = evento.data.split('/');
              if (partes.length === 3) {
                // Se o ano não for explicitamente 2025 ou maior, corrige para 2025
                const ano = parseInt(partes[2]);
                if (ano < 2025) {
                  partes[2] = '2025';
                  evento.data = partes.join('/');
                }
              }
            }
            
            return evento;
          });
          
          // Remover eventos duplicados com lógica aprimorada
          eventos = removerEventosDuplicados(eventos);
          
          // Mostrar os eventos na interface
          mostrarEventosDetectados(eventos);
        } else {
          document.getElementById("eventosContainer").innerHTML = 
            "<p>Não foi possível extrair eventos desta imagem. Verifique se é um cartaz de evento válido.</p>";
        }
        
        // Mostrar resultados e esconder loading
        document.getElementById("resultContainer").style.display = "block";
        document.getElementById("loading").style.display = "none";
        document.getElementById("processButton").disabled = false;
        
      } catch (error) {
        console.error("Erro ao processar imagem:", error);
        document.getElementById("loading").style.display = "none";
        document.getElementById("processButton").disabled = false;
        alert("Erro ao processar imagem: " + error.message);
      }
    }
    
    // Função para remover eventos duplicados com base na atração e data
    function removerEventosDuplicados(listaEventos) {
      const eventosUnicos = [];
      const chavesEventos = new Set();
      
      for (const evento of listaEventos) {
        // Criar uma chave única para cada evento baseada na atração, data e local
        // Normaliza os textos removendo espaços extras, acentos e convertendo para minúsculo
        const normalizarTexto = (texto) => {
          if (!texto) return '';
          return texto.toLowerCase()
                      .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                      .replace(/\s+/g, ' ')
                      .trim();
        };
        
        const atracao = normalizarTexto(evento.atracao);
        const data = normalizarTexto(evento.data);
        const local = normalizarTexto(evento.local);
        const hora = normalizarTexto(evento.hora);
        
        // Chave composta para identificar eventos únicos
        const chave = `${atracao}|${data}|${local}|${hora}`;
        
        // Verificar se é um evento único ou variação de um já existente
        let isDuplicado = false;
        
        // Procurar por similaridade em atrações existentes
        for (const chaveExistente of chavesEventos) {
          // Se a atração e data são as mesmas, considera como duplicado
          const [atracaoExistente, dataExistente] = chaveExistente.split('|');
          if (atracao && atracaoExistente && 
              (atracao.includes(atracaoExistente) || atracaoExistente.includes(atracao)) && 
              data === dataExistente) {
            isDuplicado = true;
            break;
          }
        }
        
        // Se não for um duplicado, adicionar à lista de eventos únicos
        if (!isDuplicado && !chavesEventos.has(chave)) {
          chavesEventos.add(chave);
          eventosUnicos.push(evento);
        }
      }
      
      return eventosUnicos;
    }
    
    // Extrair eventos do JSON na resposta do Gemini
    function extrairEventosDeJson(texto) {
      try {
        // Primeira tentativa: procurar por blocos de código JSON
        const jsonMatch = texto.match(/```json\n([\s\S]*?)\n```/) || 
                         texto.match(/```\n([\s\S]*?)\n```/) ||
                         texto.match(/{[\s\S]*?"eventos"[\s\S]*?}/);
                         
        if (jsonMatch) {
          const jsonText = jsonMatch[1] || jsonMatch[0];
          const cleanJson = jsonText.replace(/```json|```/g, '').trim();
          const parsed = JSON.parse(cleanJson);
          
          if (parsed.eventos && Array.isArray(parsed.eventos)) {
            return parsed.eventos;
          } else if (Array.isArray(parsed)) {
            return parsed;
          } else {
            // Pode ser um único evento não em array
            return [parsed];
          }
        }
        
        // Segunda tentativa: procurar qualquer objeto JSON
        const objectMatch = texto.match(/{[\s\S]*?}/g);
        if (objectMatch) {
          // Tentar cada objeto encontrado
          for (const match of objectMatch) {
            try {
              const parsed = JSON.parse(match);
              if (parsed.eventos) return parsed.eventos;
              if (parsed.atracao || parsed.nome) return [parsed];
            } catch (e) {
              console.warn("Falha ao analisar JSON candidato:", e);
            }
          }
        }
        
        return [];
      } catch (e) {
        console.error("Erro ao extrair eventos do JSON:", e);
        return [];
      }
    }
    
    // Mostrar eventos detectados na interface
    function mostrarEventosDetectados(eventos) {
      const container = document.getElementById("eventosContainer");
      container.innerHTML = '';
      
      if (!eventos || eventos.length === 0) {
        container.innerHTML = '<p>Nenhum evento detectado.</p>';
        return;
      }
      
      // Criar um card para cada evento
      eventos.forEach((evento, index) => {
        const card = document.createElement('div');
        card.className = 'event-card';
        
        // Cabeçalho do card
        const header = document.createElement('div');
        header.className = 'event-card-header';
        
        const title = document.createElement('h3');
        title.className = 'event-card-title';
        title.textContent = evento.atracao || "Evento sem nome";
        
        const date = document.createElement('span');
        date.className = 'event-card-date';
        date.textContent = evento.data || "";
        
        header.appendChild(title);
        header.appendChild(date);
        card.appendChild(header);
        
        // Conteúdo do card
        const content = document.createElement('div');
        content.className = 'event-card-content';
        
        // Adicionar campos ao conteúdo
        const campos = [
          { label: 'Horário', key: 'hora' },
          { label: 'Local', key: 'local' },
          { label: 'Cidade', key: 'cidade' },
          { label: 'Fonte', key: 'fonte' }
        ];
        
        // Adicionar campos opcionais se existirem
        if (evento.endereco) campos.push({ label: 'Endereço', key: 'endereco' });
        if (evento.preco) campos.push({ label: 'Preço', key: 'preco' });
        if (evento.tipo) campos.push({ label: 'Tipo', key: 'tipo' });
        if (evento.descricao) campos.push({ label: 'Descrição', key: 'descricao' });
        
        campos.forEach(campo => {
          if (evento[campo.key]) {
            const item = document.createElement('div');
            item.className = 'event-card-item';
            
            const label = document.createElement('div');
            label.className = 'event-card-item-label';
            label.textContent = campo.label;
            
            const value = document.createElement('div');
            value.className = 'event-card-item-value';
            value.textContent = evento[campo.key];
            
            item.appendChild(label);
            item.appendChild(value);
            content.appendChild(item);
          }
        });
        
        card.appendChild(content);
        
        // Ações do card
        const actions = document.createElement('div');
        actions.className = 'event-card-actions';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'event-select';
        checkbox.checked = true;
        checkbox.dataset.index = index;
        
        const editBtn = document.createElement('button');
        editBtn.textContent = 'Editar';
        editBtn.style.width = 'auto';
        editBtn.style.padding = '8px 15px';
        editBtn.style.marginLeft = '10px';
        editBtn.onclick = () => editarEvento(index);
        
        actions.appendChild(checkbox);
        actions.appendChild(editBtn);
        card.appendChild(actions);
        
        container.appendChild(card);
      });
    }
      // Editar um evento específico com formulário modal
    function editarEvento(index) {
      const evento = eventos[index];
      if (!evento) return;
      
      // Criar formulário modal HTML para edição mais amigável
      const modalHTML = `
      <div id="eventoModal" style="position:fixed; top:0; left:0; width:100%; height:100%; 
                                   background:rgba(0,0,0,0.6); display:flex; align-items:center; 
                                   justify-content:center; z-index:1000;">
        <div style="background:white; width:80%; max-width:500px; max-height:90vh; overflow-y:auto; 
                   border-radius:8px; padding:20px; box-shadow:0 4px 8px rgba(0,0,0,0.2);">
          <h3 style="margin-top:0; color:var(--primary);">Editar Evento</h3>
          <form id="editForm">
            <div style="margin-bottom:15px;">
              <label style="display:block; margin-bottom:5px; font-weight:bold;">Atração:</label>
              <input type="text" id="edit_atracao" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                     value="${evento.atracao || ''}">
            </div>
            
            <div style="display:flex; gap:10px; margin-bottom:15px;">
              <div style="flex:1;">
                <label style="display:block; margin-bottom:5px; font-weight:bold;">Data:</label>
                <input type="text" id="edit_data" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                       value="${evento.data || ''}">
              </div>
              <div style="flex:1;">
                <label style="display:block; margin-bottom:5px; font-weight:bold;">Hora:</label>
                <input type="text" id="edit_hora" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                       value="${evento.hora || ''}">
              </div>
            </div>
            
            <div style="margin-bottom:15px;">
              <label style="display:block; margin-bottom:5px; font-weight:bold;">Local:</label>
              <input type="text" id="edit_local" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                     value="${evento.local || ''}">
            </div>
            
            <div style="display:flex; gap:10px; margin-bottom:15px;">
              <div style="flex:1;">
                <label style="display:block; margin-bottom:5px; font-weight:bold;">Cidade:</label>
                <input type="text" id="edit_cidade" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                       value="${evento.cidade || ''}">
              </div>
              <div style="flex:1;">
                <label style="display:block; margin-bottom:5px; font-weight:bold;">Fonte:</label>
                <input type="text" id="edit_fonte" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                       value="${evento.fonte || ''}">
              </div>
            </div>
            
            <div style="margin-bottom:15px;">
              <label style="display:block; margin-bottom:5px; font-weight:bold;">Endereço:</label>
              <input type="text" id="edit_endereco" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                     value="${evento.endereco || ''}">
            </div>
            
            <div style="display:flex; gap:10px; margin-bottom:15px;">
              <div style="flex:1;">
                <label style="display:block; margin-bottom:5px; font-weight:bold;">Preço:</label>
                <input type="text" id="edit_preco" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                       value="${evento.preco || ''}">
              </div>
              <div style="flex:1;">
                <label style="display:block; margin-bottom:5px; font-weight:bold;">Tipo:</label>
                <input type="text" id="edit_tipo" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" 
                       value="${evento.tipo || ''}">
              </div>
            </div>
            
            <div style="margin-bottom:15px;">
              <label style="display:block; margin-bottom:5px; font-weight:bold;">Descrição:</label>
              <textarea id="edit_descricao" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px; height:80px;">${evento.descricao || ''}</textarea>
            </div>
            
            <div style="display:flex; justify-content:flex-end; gap:10px;">
              <button type="button" id="cancelBtn" style="background:#ccc; border:none; padding:10px 15px; border-radius:4px; cursor:pointer;">
                Cancelar
              </button>
              <button type="submit" style="background:var(--primary); color:white; border:none; padding:10px 15px; border-radius:4px; cursor:pointer;">
                Salvar
              </button>
            </div>
          </form>
        </div>
      </div>
      `;
      
      // Adicionar o modal ao DOM
      const modalContainer = document.createElement('div');
      modalContainer.innerHTML = modalHTML;
      document.body.appendChild(modalContainer);
      
      // Configurar manipuladores de eventos
      document.getElementById('cancelBtn').addEventListener('click', function() {
        document.body.removeChild(modalContainer);
      });
      
      document.getElementById('editForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Coletar valores do formulário
        const eventoAtualizado = {
          atracao: document.getElementById('edit_atracao').value,
          data: document.getElementById('edit_data').value,
          hora: document.getElementById('edit_hora').value,
          local: document.getElementById('edit_local').value,
          cidade: document.getElementById('edit_cidade').value,
          fonte: document.getElementById('edit_fonte').value,
        };
        
        // Adicionar campos opcionais apenas se tiverem conteúdo
        const endereco = document.getElementById('edit_endereco').value;
        if (endereco) eventoAtualizado.endereco = endereco;
        
        const preco = document.getElementById('edit_preco').value;
        if (preco) eventoAtualizado.preco = preco;
        
        const tipo = document.getElementById('edit_tipo').value;
        if (tipo) eventoAtualizado.tipo = tipo;
        
        const descricao = document.getElementById('edit_descricao').value;
        if (descricao) eventoAtualizado.descricao = descricao;
        
        // Atualizar o evento no array
        eventos[index] = eventoAtualizado;
        
        // Atualizar a exibição
        mostrarEventosDetectados(eventos);
        
        // Fechar o modal
        document.body.removeChild(modalContainer);
      });
    }
      // Enviar eventos selecionados para a API
    async function enviarEventos() {
      // Obter todos os cards de eventos selecionados
      const eventCards = document.querySelectorAll('.event-card');
      const selecionados = Array.from(eventCards).filter(card => 
        card.querySelector('input[type="checkbox"]').checked
      );
      
      if (selecionados.length === 0) {
        alert("Nenhum evento selecionado para envio.");
        return;
      }
      
      // Desabilitar botão durante o envio
      const sendButton = document.getElementById('sendButton');
      sendButton.disabled = true;
      sendButton.textContent = 'Enviando...';
      
      // URL da API
      const apiUrl = 'https://mtcporto2.pythonanywhere.com/eventos/default/eventos';
      
      // Contadores para feedback
      let sucessos = 0;
      let falhas = 0;
      let mensagens = [];
      
      // Processar cada evento selecionado
      for (const card of selecionados) {
        try {
          // Extrair dados do card
          const atracao = card.querySelector('.event-card-title').textContent;
          const data = card.querySelector('.event-card-date').textContent;
          
          // Buscar valores de elementos com determinados rótulos
          const getValueByLabel = (label) => {
            const labelElement = Array.from(card.querySelectorAll('.event-card-item-label'))
              .find(el => el.textContent === label);
            return labelElement?.nextElementSibling?.textContent || '';
          };
          
          // Construir objeto com dados do evento
          const evento = {
            oque: atracao,
            quando: data + ' ' + getValueByLabel('Horário:'),
            onde: getValueByLabel('Cidade:') || 'João Pessoa',
            fonte: getValueByLabel('Fonte:') || 'Mini Agente de Eventos',
            local: getValueByLabel('Local:') || 'Local não especificado'
          };
          
          // Adicionar campos opcionais se existirem
          const endereco = getValueByLabel('Endereço:');
          if (endereco) evento.endereco = endereco;
          
          const preco = getValueByLabel('Preço:');
          if (preco) evento.preco = preco;
          
          const tipo = getValueByLabel('Tipo:');
          if (tipo) evento.tipo = tipo;
          
          const descricao = getValueByLabel('Descrição:');
          if (descricao) evento.descricao = descricao;
          
          // Registrar o que será enviado
          console.log("Enviando evento:", evento);
          
          // Tentativa 1: Enviar como dados de formulário
          try {
            // Criar objeto FormData
            const formData = new FormData();
            Object.entries(evento).forEach(([key, value]) => {
              formData.append(key, value);
            });
            
            // Enviar requisição fetch
            const response = await fetch(apiUrl, {
              method: 'POST',
              body: formData,
              mode: 'cors'
            });
            
            if (response.ok) {
              const result = await response.json();
              console.log("Resposta da API:", result);
              sucessos++;
              continue; // Prosseguir para o próximo evento
            }
          } catch (err) {
            console.log("Falha ao enviar como FormData, tentando JSON:", err);
          }
          
          // Tentativa 2: Enviar como JSON
          try {
            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(evento),
              mode: 'cors'
            });
            
            if (response.ok) {
              const result = await response.json();
              console.log("Resposta da API (JSON):", result);
              sucessos++;
              continue; // Prosseguir para o próximo evento
            }
          } catch (err) {
            console.log("Falha ao enviar como JSON:", err);
          }
          
          // Se chegou aqui, ambas as tentativas falharam
          falhas++;
          mensagens.push(`Não foi possível enviar "${atracao}"`);
          
        } catch (error) {
          console.error("Erro ao processar evento:", error);
          falhas++;
          mensagens.push(`Erro ao processar "${card.querySelector('.event-card-title').textContent}": ${error.message}`);
        }
      }
      
      // Restaurar estado do botão
      sendButton.disabled = false;
      sendButton.textContent = 'Enviar para API';
      
      // Mostrar feedback final
      if (sucessos > 0) {
        alert(`${sucessos} evento(s) enviado(s) com sucesso!`);
      }
      
      if (falhas > 0) {
        alert(`${falhas} evento(s) não pôde(puderam) ser enviado(s):\n${mensagens.join('\n')}`);
      }
    }
  </script>
</body>
</html>
